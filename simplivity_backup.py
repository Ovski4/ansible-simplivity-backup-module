#!/usr/bin/python

ANSIBLE_METADATA = {
    'metadata_version': '1.0',
    'status': ['preview']
}

DOCUMENTATION = '''
---
module: simplivity_backup

short_description: Module used to manage simplivity backups

version_added: "2.8"

description:
    - "This module is used to manage simplivity backups"

options:
    username:
        description:
            - The username to be authenticated via the api
        required: true
        default: null
    password:
        description:
            - The password associated with the given vcenter username
        required: true
        default: null
    omnistack_host:
        description:
            - The host the api will be called on
        required: true
        default: null
    virtual_machine_name:
        description:
            - The name of the virtual machine for which backups will be managed
        required: true
        default: null
    backup_name:
        description:
            - The name of the backup
        required: true
        default: null
    state:
        description:
            - Whether the backup should be present, absent or restored
        required: false
        choices: [ "present", "absent", "restored" ]
        default: present
    app_consistent:
        description:
            - Whether the backup should be 'App Consistent' or not
        required: false
        choices: [ "false", "true" ]
        default: "false"
    retention:
        description:
            - The number of minutes to keep backups
        required: false
        default: 0

author:
    - Baptiste Bouchereau
'''

EXAMPLES = '''

- name: Create a simplivity backup for 2 hours
    simplivity_backup:
        backup_name: "Backup generated by Ansible the {{ lookup('pipe','date +%Y-%m-%d') }}"
        username: "your_username"
        password: "your_password"
        omnistack_host: "omnistack_host@your_domain.net"
        virtual_machine_name: "{{ inventory_hostname }}"
        retention: 120
        state: present
    delegate_to: localhost

- name: Create an app consistent simplivity backup
    simplivity_backup:
        backup_name: "Backup generated by Ansible the {{ lookup('pipe','date +%Y-%m-%d') }}"
        username: "your_username"
        password: "your_password"
        omnistack_host: "omnistack_host@your_domain.net"
        virtual_machine_name: "{{ inventory_hostname }}"
        app_consistent: "true"
        state: present
    delegate_to: localhost

- name: Delete a simplivity backup
    simplivity_backup:
        backup_name: "Backup generated by Ansible the {{ lookup('pipe','date +%Y-%m-%d') }}"
        username: "your_username"
        password: "your_password"
        omnistack_host: "omnistack_host@your_domain.net"
        virtual_machine_name: "{{ inventory_hostname }}"
        state: absent
    delegate_to: localhost

- name: Restore a simplivity backup
    simplivity_backup:
        backup_name: "Backup generated by Ansible the {{ lookup('pipe','date +%Y-%m-%d') }}"
        username: "your_username"
        password: "your_password"
        omnistack_host: "omnistack_host@your_domain.net"
        virtual_machine_name: "{{ inventory_hostname }}"
        state: restored
    delegate_to: localhost
'''

RETURN = '''
result:
    description: A message indicating what was done, and the reason if nothing changed
    type: str
    returned: always
'''

from ansible.errors import AnsibleError
import time

try:
    import requests, json, jmespath
except ImportError:
    raise AnsibleError('You need to install "requests, json and jmespath" prior to running the simplivity_backup module')

class SimplivityBackupModule(object):

    def __init__(self, module):
        self.module = module 
        self.args = self.module.params

        self.base_url = 'https://{}/api/'.format(module.params['omnistack_host'])
        self.state = self.module.params['state']
        self.backup_name = self.module.params['backup_name']
        self.app_consistent = self.module.params['app_consistent']
        self.retention = self.module.params['retention']
        self.username = module.params['username']
        self.password = module.params['password']

        self.changed = False
        self.result = ''

        self.process()

    def process(self):
        virtual_machine_name = self.module.params['virtual_machine_name']
        virtual_machines = self._request_api('virtual_machines?name={}'.format(virtual_machine_name))

        if virtual_machines.get('count') == 0:
            self.module.fail_json(msg='No virtual machine with name {} found'.format(virtual_machine_name))

        if virtual_machines.get('count') > 1:
            self.module.fail_json(msg='Multiple virtual machines with name {} found'.format(virtual_machine_name))

        virtual_machine_data = virtual_machines.get('virtual_machines')[0]
        existing_backup = self._retrieve_existing_backup(virtual_machine_data.get('id'))

        if existing_backup is not None and self.state == 'present':
            self.result = "Backup '{}' (id {}) already present".format(self.backup_name, existing_backup.get('id'))
            return

        if existing_backup is None and self.state == 'absent':
            self.result = "Backup '{}' already absent".format(self.backup_name)
            return

        if existing_backup is None and self.state == 'restored':
            self.module.fail_json(msg="Backup '{}' cannot be found and therefore cannot be restored".format(self.backup_name))
            return

        if (self.state == 'absent'):
            if not self.module.check_mode:
                self._delete_backup(existing_backup)
            self.changed = True
            self.result = "Backup '{}' (id {}) deleted".format(self.backup_name, existing_backup.get('id'))
            return

        if (self.state == 'present'):
            if not self.module.check_mode:
                self._create_backup(virtual_machine_data)
            self.changed = True
            self.result = "Backup '{}' created".format(self.backup_name)
            return

        if (self.state == 'restored'):
            if not self.module.check_mode:
                self._restore_backup(existing_backup, virtual_machine_data)
            self.changed = True
            self.result = "Backup '{}' restored".format(self.backup_name)
            return

    def _delete_backup(self, existing_backup):
        body = json.dumps({
            'backup_id': [existing_backup.get('id')]
        })
        task = self._request_api('backups/delete', 'POST', body)
        self._wait_for_task_to_complete(task, 'Backup deletion', 5, 3)

    def _restore_backup(self, existing_backup, virtual_machine_data):
        task = self._request_api('backups/{}/restore?restore_original=true'.format(existing_backup.get('id')), 'POST')
        self._wait_for_task_to_complete(task, 'Backup restoration', 10, 5)

    def _create_backup(self, virtual_machine_data):
        body = json.dumps({
            'backup_name': self.backup_name,
            'destination_id': virtual_machine_data.get('omnistack_cluster_id'),
            'app_consistent': self.app_consistent,
            'consistency_type': 'NONE' if self.app_consistent == 'false' else 'DEFAULT',
            'retention': self.retention
        })
        task = self._request_api('virtual_machines/{}/backup'.format(virtual_machine_data.get('id')), 'POST', body)
        self._wait_for_task_to_complete(task, 'Backup creation', 10, 5)

    def _wait_for_task_to_complete(self, task, task_type, seconds_between_retries, minutes_timeout):
        task_id = task.get('task').get('id')
        task_state = task.get('task').get('state')
        task_retries = 0

        while task_state != 'COMPLETED':
            if task_state == 'FAILED':
                self.module.fail_json(msg='{} task {} failed'.format(task_type, task_id))
            elif task_state == 'IN_PROGRESS':
                seconds_between_retries = 10
                maximum_retry_count = minutes_timeout * 60 / seconds_between_retries

                if (task_retries > maximum_retry_count):
                    self.module.fail_json(msg='{} task {} is still in progress after {} minutes'.format(
                        task_type,
                        task_id,
                        minutes_timeout
                    ))
                time.sleep(seconds_between_retries)
                task = self._request_api('tasks/' + task_id)
                task_retries += 1
                task_state = task.get('task').get('state')
            else:
                self.module.fail_json(
                    msg="Unknown task state '{}'. The API changed since the development of the simplivity_backup module"
                ).format(task_state)

    def _retrieve_access_token(self):
        response = requests.post(
            self.base_url + 'oauth/token',
            auth = ('simplivity', ''),
            verify = False,
            data = {
                'grant_type': 'password',
                'username': self.username,
                'password': self.password
            }
        )

        return response.json()['access_token']

    def _is_successful(self, response):
        return response.status_code >= 200 and response.status_code < 300

    def _request_api(self, path, method = 'GET', body = '{}'):
        headers = {
            'Authorization':  'Bearer ' + self._retrieve_access_token(),
            'Accept' : 'application/vnd.simplivity.v1+json'
        }

        if method == 'GET':
            response = requests.get(self.base_url + path, verify=False, headers=headers)
        elif method == 'POST':
            headers['Content-Type'] = 'application/vnd.simplivity.v1+json'
            response = requests.post(self.base_url + path, body, verify=False, headers=headers)
        else:
            self.module.fail_json(msg="Unsupported http method '{}'".format(method))

        if not self._is_successful(response):
            self.module.fail_json(
                msg='Error calling the api: {} - {} - {} \n'.format(
                    response.status_code,
                    self.base_url + path,
                    response.text
                ))

        return response.json()

    def _retrieve_existing_backup(self, virtual_machine_id):
        backup_list = self._request_api('backups?virtual_machine_id={}'.format(virtual_machine_id)).get('backups')
        existing_backup = None

        try:
            existing_backup = jmespath.search("[?name=='{}'] | [0]".format(self.backup_name), backup_list)
        except jmespath.exceptions.JMESPathError as e:
            raise AnsibleError('JMESPathError in simplivity_backup module:\n%s' % e)
        except Exception as e:
            # For older jmespath, we can get ValueError and TypeError without much info.
            raise AnsibleError('Error in jmespath.search in simplivity_backup module:\n%s' % e)

        return existing_backup

def main():

    module_args = dict(
        state = dict(
            default = 'present',
            choices = ['present', 'absent', 'restored']
        ),
        backup_name = dict(
            type = 'str',
            required = True
        ),
        app_consistent = dict(
            type = 'str',
            default = 'false',
            choices = ['false', 'true']
        ),
        retention = dict(
            type = 'int',
            default = 0
        ),
        omnistack_host = dict(
            type = 'str',
            required = True
        ),
        virtual_machine_name = dict(
            type = 'str',
            required = True
        ),
        username = dict(
            type = 'str',
            required = True
        ),
        password = dict(
            type = 'str',
            required = True,
            no_log = True
        )
    )

    module = AnsibleModule(
        argument_spec = module_args,
        supports_check_mode = True
    )

    simplivity_backup_module = SimplivityBackupModule(module)

    module.exit_json(
        changed = simplivity_backup_module.changed,
        result = simplivity_backup_module.result
    )

from ansible.module_utils.basic import AnsibleModule

if __name__ == '__main__':
    main()
